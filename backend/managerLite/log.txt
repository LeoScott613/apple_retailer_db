connection实例化成功，但是没有具体的信息，所以语句执行失败，也就没有结果集。不过即时是成功的查询，也会出现这样的现象。

之所以加载结果为空，是因为表就是空的。

所以接下来可以开始完善功能：
建立连接，但是不执行语句。

查詢功能：需要建立連接才能執行。需要接受輸入的表，然後查詢對應的表。先做主函數接受輸入功能，還有根據輸入查詢功能

只接受warehouse

试使用通用方法打印所有数据

通用输出完成

获取了表格的元数据，所以就有表头
通过元数据获取了列数
然后以列数为锚点进行循环
把数据用Obj装载
然后sout正常输出数据

修改表头打印方式

给数据库添加触发器，存储过程，事务。还有实施视图，补充完检查约束

方形代表实体，菱形代表联系，圆角矩形代表属性，联系之间要给出数字

增加插入数据功能：显示每一行的数据类型。要先增加接受操作输入的ui，还有根据输入不同而选择的不同CRUD操作

数据插入：需要知道数据类型和多少行。使用append来构造字符串。CRUD所需的sql语句构造都应该放在func包中

获取operation，然后再获取操作表.

接下来添加插入功能了，还有修改ui。增加了中文表名识别

java编译流程：编译类controller的时候，java会检测B有没有被改变，如果B被改变了，那么Java会编译B

将输入的逻辑移入constructor，constructor就需要建立scanner对象。
所有CRUD的语句构造都需要输入信息
构造完的输入语句返回来，由controller交给statement执行就好

做到了insert逻辑的输入提示功能

insert构造器知道表名之后，还需要获取元数据才能。

新思路：不用静态类了。一个构造器类需要获取了表名后才能执行构造的功能。

但是这样的构造器好像真的就只是起到一个String format的作用？
不，它从controller中省去了使用while和append配合的代码

getColumnType返回的数值和库里提供的常量值去比较即可

下一步：优化插入逻辑，切实地把插入语句放进数据库中执行。并且做数据库的存储过程和事务

日志中操作员信息应该从哪里来呢？操作员是登录的时候决定的吧。登录的信息应该放在某个表里？
已删除操作员信息

增加登录界面，先添加管理员信息

根据输入建设query语句的过程应该放在后面

查询全表时不需要把元数据传进去（暂时），如果需要的话，以insert的方法为范式即可
表格还应该设计范式

复习代码？重看代码能够回忆当时是怎么实现的，每次重看的时候都觉得记忆被唤醒了一点。
像sql.types.integer常量比较这种操作，像StringBuilder这种类
一知半解地写上去，只有再看，或者继续拓展，才能固化到记忆中去，才能理解它的本质，才能在下次不被类似问题困扰
我现在的确很难称得上精通某个技术，我应该重新规划技术能力和其他能力的发展

修改：先输入表，再输入操作

update：获取全表，然后输入想改的属性名

插入成功，但是仍然抛出错误

big mistake：无法更新raw表

接下来的工作，更改表名